grammar org.myasm.assembly.compiler.MyAsm hidden(WS, DOC_COMMENT, SL_COMMENT)

generate myAsm "http://www.myasm.org/assembly/compiler/MyAsm"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// ===============================================
// ===              Java Program               ===
// ===============================================

Program:
	program=CompilationUnit
;

CompilationUnit:
    package=PackageDeclaration? imports+=ImportDeclaration* declarations+=TypeDeclaration*
;

// ===============================================
// ===               Declarations              ===
// ===============================================

PackageDeclaration:
    => PACKAGE name=PackageName ";"
;

ImportDeclaration:
    => IMPORT ( name=PackageName ".*" | name=TypeName ) ";"
;

TypeDeclaration:
    ClassDeclaration | InterfaceDeclaration
;

ClassDeclaration:
    visibility=PUBLIC? modifiers+=ClassModifier*
    CLASS name=IDENTIFIER extends=SuperClass? implements=Interfaces? body=ClassBody
;

VisibilityModifier:
    PUBLIC | PROTECTED | PRIVATE
;

ClassModifier:
    ABSTRACT | FINAL
;

SuperClass:
    EXTENDS name=ClassName
;

Interfaces returns InterfaceList:
    keyword=IMPLEMENTS interfaces+=InterfaceName ( => "," interfaces+=InterfaceName )*
;

ClassBody returns DeclarationBody:
    "{" declarations+=ClassBodyDeclaration* "}"
;

ClassBodyDeclaration:
    ClassMemberDeclaration | StaticInitializer | ConstructorDeclaration
;

ClassMemberDeclaration:
    FieldDeclaration | MethodDeclaration
;

StaticInitializer:
    STATIC code=Block
;

ConstructorDeclaration:
    visibility=VisibilityModifier?
    header=ConstructorDeclarator throws=Exceptions? body=ConstructorBody
;

ConstructorDeclarator:
    name=IDENTIFIER
    "(" ( params+=FormalParameter ( => "," params+=FormalParameter )* )? ")"
;

FormalParameter:
    type=Type variable=VariableDeclaratorId
;

Exceptions:
    THROWS exceptions+=ClassName ( => "," exceptions+=ClassName )*
;

ConstructorBody returns DeclarationBody:
    "{" invocation=ExplicitConstructorInvocation? => declarations+=BlockStatement* "}"
;

ExplicitConstructorInvocation:
    ( keyword=THIS "(" args=ArgumentList? ")" ) | ( keyword=SUPER "(" args=ArgumentList? ")" )
;

ArgumentList:
    declarations+=Expression ( => "," declarations+=Expression )*
;

FieldDeclaration returns Attribute:
    visibility=VisibilityModifier? modifiers+=FieldModifier*
    type=Type declarations+=VariableDeclarator ( => "," declarations+=VariableDeclarator )* ";"
;

FieldModifier:
    STATIC | FINAL | TRANSIENT | VOLATILE
;

VariableDeclarator:
    facade=VariableDeclaratorId
    ( "=" definition=VariableInitializer )?
;

VariableDeclaratorId:
    name=IDENTIFIER layers+=( "[]" )*
;

VariableInitializer:
    Expression | ArrayInitializer
;

MethodDeclaration returns Method:
    signature=MethodHeader body=MethodBody
;

MethodHeader:
    visibility=VisibilityModifier? modifiers+=MethodModifier*
    type=ResultType header=MethodDeclarator throws=Exceptions?
;

MethodModifier:
    STATIC | ABSTRACT | FINAL | SYNCHRONIZED | NATIVE
;

MethodDeclarator:
    name=IDENTIFIER
    "(" ( params+=FormalParameter ( => "," params+=FormalParameter)* )? ")"
;

MethodBody:
    Block | ";"
;

InterfaceDeclaration:
    visibility=PUBLIC? modifiers+=ABSTRACT?
    INTERFACE name=IDENTIFIER extends=ExtendsInterfaces? body=InterfaceBody
;

ExtendsInterfaces returns InterfaceList:
    keyword=EXTENDS interfaces+=InterfaceName ( => "," interfaces+=InterfaceName )*
;

InterfaceBody returns DeclarationBody:
    "{" declarations+=InterfaceMemberDeclaration* "}"
;

InterfaceMemberDeclaration:
    ConstantDeclaration | AbstractMethodDeclaration
;

ConstantDeclaration returns Attribute:
    visibility=VisibilityModifier? modifiers+=ConstantModifiers*
    type=Type declarations+=VariableDeclarator
;

ConstantModifiers:
    STATIC | FINAL
;

AbstractMethodDeclaration returns Method:
    signature=AbstractMethodHeader ";"
;

AbstractMethodHeader:
    visibility=PUBLIC? modifiers+=ABSTRACT?
    type=ResultType header=MethodDeclarator throws=Exceptions?
;

ArrayInitializer:
    "{" ( definitions+=VariableInitializer ( => "," definitions+=VariableInitializer )* )? ","? "}"
;

// ===============================================
// ===                  Types                  ===
// ===============================================

ResultType:
    Type | VoidType
;

Type:
    TypeSpecifier ( "[]" )*
;

TypeSpecifier:
    BooleanType
    | ByteType
    | ShortType
    | IntType
    | FloatType
    | LongType
    | DoubleType
    | CharacterType
    | ObjectType
;

CharacterType:
    {CharType} name=CHAR
;

BooleanType:
    {BooleanType} name=BOOLEAN
;

ObjectType:
    {ObjectType} name=TypeName
;

VoidType:
    {VoidType} name=VOID
;

DoubleType:
    {DoubleType} name=DOUBLE
;

LongType:
    {LongType} name=LONG
;

ByteType:
    {ByteType} name=BYTE
;

ShortType:
    {ShortType} name=SHORT
;

FloatType:
    {FloatType} name=FLOAT
;

IntType:
    {IntType} name=INTEGER
;

// ===============================================
// ===          Blocks and Commands            ===
// ===============================================

Block returns DeclarationBody:
    "{" declarations+=BlockStatement* "}"
;

BlockStatement:
    ( LocalVariableDeclaration ";" ) | Statement
;

LocalVariableDeclaration returns Variable:
    type=Type declarations+=VariableDeclarator (=> "," declarations+=VariableDeclarator )*
;

Statement:
    EmptyStatement
    | LabeledStatement
    | IfStatement
    | WhileStatement
    | ForStatement
    | Block
    | ( Expression ";" )
    | SwitchStatement
    | DoStatement
    | BreakStatement
    | ContinueStatement
    | ReturnStatement
    | SynchronizedStatement
    | ThrowsStatement
    | TryStatement
;

EmptyStatement:
    ";"
;

LabeledStatement:
    label=IDENTIFIER ":" statement=Statement
;

IfStatement:
    IF "(" condition?=Expression ")" then=Statement
    ( => ELSE else=Statement )?
;

SwitchStatement:
    SWITCH "(" expression=Expression ")" "{"
    ( ( CASE   constants+=Expression ":" )
    | ( DEFAULT ":" )
    | statements+=BlockStatement )* "}"
;

WhileStatement:
    WHILE "(" condition?=Expression ")" statement=Statement
;

DoStatement:
    DO statement=Statement WHILE "(" condition?=Expression ")" ";"
;

ForStatement:
    FOR "(" initExpr=ForInit? ";" condition?=Expression? ";" updateExpr=Expression? ")"
    statement=Statement
;

ForInit:
    Expression | LocalVariableDeclaration
;

BreakStatement:
    BREAK    reference=IDENTIFIER? ";"
;

ContinueStatement:
    CONTINUE reference=IDENTIFIER? ";"
;

ReturnStatement:
    RETURN expression=Expression? ";"
;

ThrowsStatement:
    THROW  expression=Expression  ";"
;

SynchronizedStatement:
    SYNCHRONIZED "(" expression=Expression ")" body=Block
;

TryStatement:
    TRY tryBody=Block
    ( => CATCH "(" params+=FormalParameter ")" catchesBody+=Block )*
    ( => FINALLY finallyBody=Block )?
;

// ===============================================
// ===                 Expression              ===
// ===============================================

Expression:
        NumericExpression
;

NumericExpression returns Expression:
      => PrefixNumericExpression
    | => PosfixNumericExpression
    | => ( BitExpression ( {NumericExpression.left=current}
    operator=( "+" | "+=" | "-" | "-=" | "*" | "*=" | "/" | "/=" | "%" | "%=" ) right=BitExpression )* )
;

PrefixNumericExpression:
    operator=( "++" | "--" | "+" | "-" ) right=BitExpression
;

PosfixNumericExpression:
    left=BitExpression operator=( "++" | "--" )
;

BitExpression returns Expression:
      => PrefixBitExpression
    | => ( LogicalExpression ( {BitExpression.left=current}
    operator=( ">>=" | "<<" | ">>" | ">>>" ) right=LogicalExpression )* )
;

PrefixBitExpression:
    operator="~" right=LogicalExpression
;

LogicalExpression returns Expression:
      => PrefixLogicalExpression
    | => ( TestingExpression
    ( {LogicalExpression.left=current}
    operator=( "&" | "&=" | "|" | "|=" | "^" | "^=" | "&&" | "||=" | "||" )
    right=TestingExpression )* )
    | => ( TestingExpression
    ( ( {LogicalExpression.left=current} "?" right=TestingExpression
    { LogicalExpression.ternary=current} ":" ternary=TestingExpression )
    | ( {LogicalExpression.left=current}
    operator=INSTANCEOF class=ObjectType ) )? )
;

PrefixLogicalExpression:
    operator="!" right=TestingExpression
;

TestingExpression returns Expression:
    CastExpression
    ( {TestingExpression.left=current}
    operator=( ">" | "<" | ">=" | "<=" | "==" | "!=" ) right=CastExpression )*
;

CastExpression:
    => ( "(" types+=TypeSpecifier ")" )* expression=PrimaryExpression
;

PrimaryExpression:
    => PrimaryNoNewArray | PrimaryNewArray
;

PrimaryNoNewArray returns PrimaryExpression:
    ( Primary | CreatingExpression | MethodInvocation | ParenthesisExpression )
    => ( ( "." fields+=IDENTIFIER ( "(" args+=ArgumentList? ")" )? ) | ( "[" dimensions+=Expression "]" ) )*
;

PrimaryNewArray returns PrimaryExpression:
    ArrayCreationExpression
    => ( ( "." fields+=IDENTIFIER ( "(" args+=ArgumentList? ")" )? ) | ( "[" dimensions+=Expression "]" ) )*
;

Primary:
    Literal | Reference
;

CreatingExpression:
    ClassInstanceCreationExpression | ArrayCreationExpression
;

ParenthesisExpression:
    => "(" Expression ")"
;

MethodInvocation:
    => method=MethodName "(" args+=ArgumentList? ")"
;

ClassInstanceCreationExpression:
    NEW type=ObjectType "(" args+=ArgumentList? ")"
;

ArrayCreationExpression:
    NEW type=TypeSpecifier
    ( => "[" dimensions+=Expression "]" )+ layers+=( "[]" )*
;

// ===============================================
// ===                 Tokens                  ===
// ===============================================

PackageName:
    IDENTIFIER
    ( => "." IDENTIFIER )*
;

TypeName:
    IDENTIFIER
    ( => "." IDENTIFIER )*
;

MethodName:
    IDENTIFIER
    ( => "." IDENTIFIER )*
;

ClassName:
    TypeName
;

InterfaceName:
    TypeName
;

// ===============================================
// ===                 Literals                ===
// ===============================================

Literal:
     => IntegerLiteral
    |=> FloatingLiteral
    | BooleanLiteral
    | CharacterLiteral
    | StringLiteral
    | NullLiteral
;

Reference:
    ThisLiteral | SuperLiteral | ObjectLiteral
;

IntegerLiteral:
    value=( DECIMAL_NUMERAL | HEX_NUMERAL | OCTAL_NUMERAL )
    suffix=( "l" | "L" )?
;

FloatingLiteral:
    value=( FloatingFullValue | FloatingPartValue | DECIMAL_NUMERAL )
    complement=FloatingComplement? suffix=( "f" | "F" | "d" | "D" )?
;

FloatingFullValue :
    => DECIMAL_NUMERAL "." DECIMAL_NUMERAL*
;

FloatingPartValue :
    => "." DECIMAL_NUMERAL
;

FloatingComplement:
    ( "e" | "E" ) ( "+" | "-" ) DECIMAL_NUMERAL+
;

BooleanLiteral:
    value=( TRUE | FALSE )
;

ThisLiteral:
    value=THIS
;

SuperLiteral:
    value=SUPER
;

NullLiteral:
    value=NULL
;

StringLiteral:
    value=STRING
;

CharacterLiteral:
    value=CHARACTER
;

ObjectLiteral:
    value=IDENTIFIER
;

// ===============================================
// ===                Terminals                ===
// ===============================================

terminal DOC_COMMENT:
    "/*" -> "*/"
;

terminal SL_COMMENT:
    "//" !( "\n" | "\r" )* ( "\r"? "\n" )?
;

terminal WS:
    ( " " | "\t" | "\r" | "\n" )+
;

//terminal NUMERIC_OPERATOR:
//    ( "+" | "+=" | "-" | "-=" | "*" | "*=" | "/" | "/=" | "%" | "%=" )
//;

//terminal BIT_OPERATOR:
//    ( ">>=" | "<<" | ">>" | ">>>" )
//;

//terminal LOGICAL_OPERATOR:
//    ( "&" | "&=" | "|" | "|=" | "^" | "^=" | "&&" | "||=" | "||" )
//;

//terminal TESTING_OPERATOR:
//    ( ">" | "<" | ">=" | "<=" | "==" | "!=" )
//;

terminal ABSTRACT:
    "abstract"
;

terminal AMPERSAND:
    "ampersand"
;

terminal BOOLEAN:
    "boolean"
;

terminal BREAK:
    "break"
;

terminal BYTE:
    "byte"
;

terminal CASE:
    "case"
;

terminal CATCH:
    "catch"
;

terminal CHAR:
    "char"
;

terminal CLASS:
    "class"
;

terminal CONST:
    "const"
;

terminal CONTINUE:
    "continue"
;

terminal DEFAULT:
    "default"
;

terminal DO:
    "do"
;

terminal DOUBLE:
    "double"
;

terminal ELSE:
    "else"
;

terminal EXTENDS:
    "extends"
;

terminal FALSE:
    "false"
;

terminal FINAL:
    "final"
;

terminal FINALLY:
    "finally"
;

terminal FLOAT:
    "float"
;

terminal FOR:
    "for"
;

terminal GOTO:
    "goto"
;

terminal IF:
    "if"
;

terminal IMPLEMENTS:
    "implements"
;

terminal IMPORT:
    "import"
;

terminal INSTANCEOF:
    "instanceof"
;

terminal INTEGER:
    "int"
;

terminal INTERFACE:
    "interface"
;

terminal LONG:
    "long"
;

terminal NATIVE:
    "native"
;

terminal NEW:
    "new"
;

terminal NULL:
    "null"
;

terminal PACKAGE:
    "package"
;

terminal PRIVATE:
    "private"
;

terminal PROTECTED:
    "protected";

terminal PUBLIC:
    "public"
;

terminal RETURN:
    "return"
;

terminal SHORT:
    "short"
;

terminal STATIC:
    "static"
;

terminal SUPER:
    "super"
;

terminal SWITCH:
    "switch"
;

terminal SYNCHRONIZED:
    "synchronized"
;

terminal THIS:
    "this"
;

terminal THREADSAFE:
    "threadsafe"
;

terminal THROW:
    "throw"
;

terminal THROWS:
    "throws"
;

terminal TRANSIENT:
    "transient"
;

terminal TRY:
    "try"
;

terminal TRUE:
    "true"
;

terminal VOID:
    "void"
;

terminal VOLATILE:
    "volatile"
;

terminal WHILE:
    "while"
;

terminal IDENTIFIER:
    ( "a".."z" | "A".."Z" |"_" |"$" )
    ( "a".."z" | "A".."Z" |"_" |"$" | "0".."9" )*
;

terminal DECIMAL_NUMERAL:
    "0" | ( NON_ZERO_DIGIT DIGIT* )
;

terminal fragment DIGIT:
    "0" | NON_ZERO_DIGIT
;

terminal fragment NON_ZERO_DIGIT:
    "1" .. "9"
;

terminal HEX_NUMERAL:
    ( "0x" | "0X" ) HEX_DIGIT+
;

terminal fragment HEX_DIGIT:
    "0" .. "9" | "a" .. "f" | "A" .. "F"
;

terminal OCTAL_NUMERAL:
    "0" OCTAL_DIGIT+
;

terminal fragment OCTAL_DIGIT:
    "0" .. "7"
;

terminal CHARACTER:
    "'" . | !( "\\" | "'" ) "'"
;

terminal STRING:
    '"' ( "\\" . | !( "\\" | '"' ) )* '"'
;