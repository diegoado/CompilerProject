grammar org.myasm.assembly.compiler.MyAsm hidden(WS, DOC_COMMENT, SL_COMMENT)

generate myAsm "http://www.myasm.org/assembly/compiler/MyAsm"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// ===============================================
// ===              Java Program               ===
// ===============================================

Program:
	program=CompilationUnit
;

CompilationUnit:
    package=PackageDeclaration? imports+=ImportDeclaration* declarations+=TypeDeclaration*
;

// ===============================================
// ===               Declarations              ===
// ===============================================

PackageDeclaration:
    => PACKAGE name=PackageName ";"
;

ImportDeclaration:
    => IMPORT ( package=PackageName ".*" | object=TypeName ) ";"
;

TypeDeclaration:
    ClassDeclaration | InterfaceDeclaration
;

ClassDeclaration:
    modifiers+=ClassModifier*
    CLASS name=IDENTIFIER extends=SuperClass? implements=Interfaces? body=ClassBody
;

ClassModifier:
    PUBLIC | ABSTRACT | FINAL
;

SuperClass:
    EXTENDS name=ClassName
;

Interfaces returns InterfaceList:
    keyword=IMPLEMENTS interfaces+=InterfaceName (=> "," interfaces+=InterfaceName )*
;

ClassBody returns BodyCode:
    "{" declarations+=ClassBodyDeclaration* "}"
;

ClassBodyDeclaration:
    ClassMemberDeclaration | StaticInitializer | ConstructorDeclaration
;

ClassMemberDeclaration:
    FieldDeclaration | MethodDeclaration
;

StaticInitializer:
    STATIC code=Block
;

ConstructorDeclaration:
    modifiers+=ConstructorModifier*
    header=ConstructorDeclarator throws=Exceptions? body=ConstructorBody
;

ConstructorModifier:
    PUBLIC | PROTECTED | PRIVATE
;

ConstructorDeclarator:
    name=SimpleTypeName
    "(" ( params+=FormalParameter (=> "," params+=FormalParameter )* )? ")"
;

FormalParameter:
    type=Type variable=VariableDeclaratorId
;

Exceptions:
    THROWS exceptions+=ClassName (=> "," exceptions+=ClassName )*
;

ConstructorBody returns BodyCode:
    "{" invocation=ExplicitConstructorInvocation? => declarations+=BlockStatement* "}"
;

ExplicitConstructorInvocation:
    ( keyword=THIS "(" args=ArgumentList? ")" ) | ( keyword=SUPER "(" args=ArgumentList? ")" )
;

FieldDeclaration returns Attribute:
    {Variable} modifiers+=FieldModifier*
    type=Type declarations+=VariableDeclarator (=> "," declarations+=VariableDeclarator )* ";"
;

FieldModifier:
    PUBLIC | PROTECTED | PRIVATE | STATIC | FINAL | TRANSIENT | VOLATILE
;

VariableDeclarator:
    facade=VariableDeclaratorId
    ( "=" definition=VariableInitializer )?
;

VariableDeclaratorId:
    name=IDENTIFIER layers+=( "[]" )*
;

VariableInitializer:
    Expression | ArrayInitializer
;

MethodDeclaration returns Method:
    signature=MethodHeader ( body=Block | ";" )
;

MethodHeader:
    modifiers+=MethodModifier*
    type=ResultType header=MethodDeclarator throws=Exceptions?
;

MethodModifier:
    PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL | SYNCHRONIZED | NATIVE
;

MethodDeclarator:
    name=IDENTIFIER
    "(" ( params+=FormalParameter (=> "," params+=FormalParameter)* )? ")"
;

InterfaceDeclaration:
    modifiers+=InterfaceModifier*
    INTERFACE name=IDENTIFIER extends=ExtendsInterfaces? body=InterfaceBody
;

InterfaceModifier:
    PUBLIC | ABSTRACT
;

ExtendsInterfaces returns InterfaceList:
    keyword=EXTENDS interfaces+=InterfaceName ( "," interfaces+=InterfaceName )*
;

InterfaceBody returns BodyCode:
    "{" declarations+=InterfaceMemberDeclaration* "}"
;

InterfaceMemberDeclaration:
    ConstantDeclaration | AbstractMethodDeclaration
;

ConstantDeclaration returns Variable:
    modifiers+=ConstantModifiers* type=Type declarations+=VariableDeclarator
;

ConstantModifiers:
    PUBLIC | STATIC | FINAL
;

AbstractMethodDeclaration returns Method:
    modifiers+=AbstractMethodModifier*
    type=ResultType header=MethodDeclarator throws=Exceptions? ";"
;

AbstractMethodModifier:
    PUBLIC | ABSTRACT
;

ArrayInitializer:
    "{" ( definitions+=VariableInitializer (=> "," definitions+=VariableInitializer )* )? ","? "}"
;

// ===============================================
// ===                  Types                  ===
// ===============================================

ResultType returns Type:
    Type | VoidType
;

Type returns Type:
    ( PrimitiveType | ReferenceName ) ( "[]" )*
;

TypeSpecifier:
    BooleanType
    | ByteType
    | ShortType
    | IntType
    | FloatType
    | LongType
    | DoubleType
    | CharacterType
    | ObjectType
;

PrimitiveType:
    NumericType  | BooleanType | CharacterType
;

NumericType:
    IntegralType | FloatingType
;

IntegralType:
    BYTE | SHORT | INT | LONG
;

FloatingType:
    FloatType | DoubleType
;

CharacterType:
    {CharType} name=CHAR
;

BooleanType:
    {BooleanType} name=BOOLEAN
;

ObjectType:
    {ObjectType} name=TypeName
;

VoidType:
    {VoidType} name=VOID
;

DoubleType:
    {DoubleType} name=DOUBLE
;

LongType:
    {LongType} name=LONG
;

ByteType:
    {ByteType} name=BYTE
;

ShortType:
    {ShortType} name=SHORT
;

FloatType:
    {FloatType} name=FLOAT
;

IntType:
    {IntType} name=INT
;

// ===============================================
// ===          Blocks and Commands            ===
// ===============================================

Block:
    "{" declarations+=BlockStatement* "}"
;

BlockStatement:
    ( LocalVariableDeclaration ";" ) | Statement
;

LocalVariableDeclaration returns Variable:
    type=Type declarations+=VariableDeclarator (=> "," declarations+=VariableDeclarator )*
;

Statement:
    EmptyStatement
    | LabeledStatement
    | IfStatement
    | WhileStatement
    | ForStatement
    | Block
    | ( Expression ";" )
    | SwitchStatement
    | DoStatement
    | BreakStatement
    | ContinueStatement
    | ReturnStatement
    | SynchronizedStatement
    | ThrowsStatement
    | TryStatement
;

EmptyStatement:
    ";"
;

LabeledStatement:
    label=IDENTIFIER ":" statement=Statement
;

IfStatement:
    IF "(" condition?=Expression ")" then=Statement
    (=> ELSE else=Statement )?
;

SwitchStatement:
    SWITCH "(" expression=Expression ")" "{"
    ( ( CASE   constants+=Expression ":" )
    | ( DEFAULT ":" )
    | statements+=BlockStatement )* "}"
;

WhileStatement:
    WHILE "(" condition?=Expression ")" statement=Statement
;

DoStatement:
    DO statement=Statement WHILE "(" condition?=Expression ")" ";"
;

ForStatement:
    FOR "(" initExpr=ForInit? ";" condition?=Expression? ";" updateExpr=Expression? ")"
    statement=Statement
;

ForInit:
    Expression | LocalVariableDeclaration
;

BreakStatement:
    BREAK    reference=IDENTIFIER? ";"
;

ContinueStatement:
    CONTINUE reference=IDENTIFIER? ";"
;

ReturnStatement:
    RETURN expression=Expression? ";"
;

ThrowsStatement:
    THROW  expression=Expression  ";"
;

SynchronizedStatement:
    SYNCHRONIZED "(" expression=Expression ")" body=Block
;

TryStatement:
    TRY tryBody=Block
    (=> CATCH "(" params+=FormalParameter ")" catchesBody+=Block )*
    (=> FINALLY finallyBody=Block )?
;

// ===============================================
// ===                 Expression              ===
// ===============================================

Expression:
    NumericExpression | Assignment
;

Assignment returns Assignment:
    object=ReferencedObject token="=" expression=Expression
;

ReferencedObject:
    => ExpressionName /*| => FieldAccess | => ArrayAccess*/
;

NumericExpression returns Expression:
    ( "++" | "--" | "-" ) BitExpression
    | BitExpression
    ( postfixToken=( "++" | "--" )
    | ( {Expression.left=current} tokens+=NUMERIC_OPERATOR right=BitExpression )* )
;

BitExpression returns Expression:
    ( '~' LogicalExpression )
    | LogicalExpression
    ( {BitExpression.left=current} tokens+=BIT_OPERATOR right=LogicalExpression )*
;

LogicalExpression returns Expression:
    ( '!' TestingExpression )
    | TestingExpression
    ( ( {LogicalExpression.left=current} tokens+=LOGICAL_OPERATOR right=TestingExpression )
    | ( {LogicalExpression.left=current}  '?' right=TestingExpression
      {LogicalExpression.ternary=current} ':' else =TestingExpression )
    | ( {LogicalExpression.left=current} tokens+=INSTANCEOF ClassName ) )*
;

TestingExpression returns Expression:
    ArgumentExpression
    ( {TestingExpression.left=current} tokens+=TESTING_OPERATOR right=ArgumentExpression )*
//    | {TestingExpression} => TRUE
//    | {TestingExpression} => FALSE
;

ArgumentExpression returns Expression:
    CastingExpression ( ( '(' args+=ArgumentList? ')' )
    | ( {ArgsExpression.left=current} '.' right=CastingExpression )
    | ( {ArgsExpression.left=current} '[' right=CastingExpression ']' )
    | ( {ArgsExpression.left=current} ',' right=CastingExpression  )  )*
;

ArgumentList:
    declarations+=CastingExpression ( "," declarations+=CastingExpression )*
;

CastingExpression returns Expression:
    CreatingExpression ( {CastingExpression.left=current} '(' types+=Type ')'
    right=CreatingExpression )*
;

CreatingExpression returns Expression:
    ParenthesisExpression
    ( NEW ( => ( ClassName '(' ( args+=ArgumentList )? ')' )
    | ( typeSpecifiers+=TypeSpecifier ( => '[' parenthesis+=ParenthesisExpression ']' )? "[]"*
    ) ) )* ;

ParenthesisExpression returns Expression:
    PrimaryExpression ( '(' parenthesis+=PrimaryExpression ')' )*
;

PrimaryExpression returns Expression:
    primary=( Literal | Object )
;

// ===============================================
// ===                 Tokens                  ===
// ===============================================

PackageName:
    IDENTIFIER
    (=> "." IDENTIFIER )*
;

TypeName:
    IDENTIFIER
    (=> "." IDENTIFIER )*
;

SimpleTypeName:
    IDENTIFIER
;

ExpressionName:
    IDENTIFIER
    (=> "." IDENTIFIER )*
;

//MethodName:
//    IDENTIFIER
//    (=> "." IDENTIFIER )*
//;
//
//AmbiguousName:
//    IDENTIFIER
//    ( => "." IDENTIFIER )*
//;

ReferenceName:
    TypeName
;

ClassName:
    TypeName
;

InterfaceName:
    TypeName
;

// ===============================================
// ===                 Literals                ===
// ===============================================

Literal:
     => IntegerLiteral
    |=> FloatingLiteral
    | BooleanLiteral
    | CharacterLiteral
    | StringLiteral
    | NullLiteral
;

Object:
    ThisLiteral | SuperLiteral | ObjectLiteral
;

IntegerLiteral:
    {IntType} value=( DECIMAL_NUMERAL | HEX_NUMERAL | OCTAL_NUMERAL )
    suffix=( "l" | "L" )?
;

FloatingLiteral:
    {FloatType} value=( FloatingFullValue | FloatingPartValue | DECIMAL_NUMERAL )
    complement=FloatingComplement? suffix=( "f" | "F" | "d" | "D" )?
;

FloatingFullValue :
    => DECIMAL_NUMERAL "." DECIMAL_NUMERAL*
;

FloatingPartValue :
    => "." DECIMAL_NUMERAL
;

FloatingComplement:
    ( "e" | "E" ) ( "+" | "-" ) DECIMAL_NUMERAL+
;

BooleanLiteral:
    {BooleanType} value=( TRUE | FALSE )
;

ThisLiteral:
    {ThisType} value=THIS
;

SuperLiteral:
    {SuperType} value=SUPER
;

NullLiteral:
    {NullType} value=NULL
;

StringLiteral:
    {ObjectType} value=STRING
;

CharacterLiteral:
    {CharType} value=CHARACTER
;

ObjectLiteral:
    {ObjectType} value=IDENTIFIER
;

// ===============================================
// ===                Terminals                ===
// ===============================================

terminal DOC_COMMENT:
    "/*" -> "*/"
;

terminal SL_COMMENT:
    "//" !( "\n" | "\r" )* ( "\r"? "\n" )?
;

terminal WS:
    ( " " | "\t" | "\r" | "\n" )+
;

terminal NUMERIC_OPERATOR:
    ( '+' | '+=' | '-' | '-=' | '*' | '*=' | '/' | '/=' | '%' | '%=' )
;

terminal BIT_OPERATOR:
    ( '>>=' | '<<' | '>>' | '>>>' )
;

terminal LOGICAL_OPERATOR:
    ( "&" | "&=" | '|' | '|=' | '^' | "^=" | "&&" | "||=" | "||" )
;

terminal TESTING_OPERATOR:
    ( '>' | '<' | '>=' | '<=' | '==' | '!=' )
;

terminal ABSTRACT:
    "abstract"
;

terminal AMPERSAND:
    "ampersand"
;

terminal BOOLEAN:
    "boolean"
;

terminal BREAK:
    "break"
;

terminal BYTE:
    "byte"
;

terminal CASE:
    "case"
;

terminal CATCH:
    "catch"
;

terminal CHAR:
    "char"
;

terminal CLASS:
    "class"
;

terminal CONST:
    "const"
;

terminal CONTINUE:
    "continue"
;

terminal DEFAULT:
    "default"
;

terminal DO:
    "do"
;

terminal DOUBLE:
    "double"
;

terminal ELSE:
    "else"
;

terminal EXTENDS:
    "extends"
;

terminal FALSE:
    "false"
;

terminal FINAL:
    "final"
;

terminal FINALLY:
    "finally"
;

terminal FLOAT:
    "float"
;

terminal FOR:
    "for"
;

terminal GOTO:
    "goto"
;

terminal IF:
    "if"
;

terminal IMPLEMENTS:
    "implements"
;

terminal IMPORT:
    "import"
;

terminal INSTANCEOF:
    "instanceof"
;

terminal INT:
    "int"
;

terminal INTERFACE:
    "interface"
;

terminal LONG:
    "long"
;

terminal NATIVE:
    "native"
;

terminal NEW:
    "new"
;

terminal NULL:
    "null"
;

terminal PACKAGE:
    "package"
;

terminal PRIVATE:
    "private"
;

terminal PROTECTED:
    "protected";

terminal PUBLIC:
    "public"
;

terminal RETURN:
    "return"
;

terminal SHORT:
    "short"
;

terminal STATIC:
    "static"
;

terminal SUPER:
    "super"
;

terminal SWITCH:
    "switch"
;

terminal SYNCHRONIZED:
    "synchronized"
;

terminal THIS:
    "this"
;

terminal THREADSAFE:
    "threadsafe"
;

terminal THROW:
    "throw"
;

terminal THROWS:
    "throws"
;

terminal TRANSIENT:
    "transient"
;

terminal TRY:
    "try"
;

terminal TRUE:
    "true"
;

terminal VOID:
    "void"
;

terminal VOLATILE:
    "volatile"
;

terminal WHILE:
    "while"
;

terminal IDENTIFIER:
    ( "a".."z" | "A".."Z" |"_" |"$" )
    ( "a".."z" | "A".."Z" |"_" |"$" | "0".."9" )*
;

terminal DECIMAL_NUMERAL:
    "0" | ( NON_ZERO_DIGIT DIGIT* )
;

terminal fragment DIGIT:
    "0" | NON_ZERO_DIGIT
;

terminal fragment NON_ZERO_DIGIT:
    "1" .. "9"
;

terminal HEX_NUMERAL:
    ( "0x" | "0X" ) HEX_DIGIT+
;

terminal fragment HEX_DIGIT:
    "0" .. "9" | "a" .. "f" | "A" .. "F"
;

terminal OCTAL_NUMERAL:
    "0" OCTAL_DIGIT+
;

terminal fragment OCTAL_DIGIT:
    "0" .. "7"
;

terminal CHARACTER:
    "'" . | !( "\\" | "'" ) "'"
;

terminal STRING:
    '"' ( "\\" . | !( "\\" | '"' ) )* '"'
;