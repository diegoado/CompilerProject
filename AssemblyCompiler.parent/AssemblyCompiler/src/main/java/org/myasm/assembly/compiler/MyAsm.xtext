grammar org.myasm.assembly.compiler.MyAsm hidden(WS, DOC_COMMENT, SL_COMMENT)

generate myAsm "http://www.myasm.org/assembly/compiler/MyAsm"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Program :
    program=CompilationUnit
;

terminal ABSTRACT :
    "abstract"
;

terminal AMPERSAND :
    "ampersand"
;

terminal BOOLEAN :
    "boolean"
;

terminal BREAK :
    "break"
;

terminal BYTE :
    "byte"
;

terminal CASE :
    "case"
;

terminal CATCH :
    "catch"
;

terminal CHAR :
    "char"
;

terminal CLASS :
    "class"
;

terminal CONST :
    "const"
;

terminal CONTINUE :
    "continue"
;

terminal DEFAULT :
    "default"
;

terminal DO:
    "do"
;

terminal DOUBLE :
    "double"
;

terminal ELSE :
    "else"
;

terminal EXTENDS :
    "extends"
;

terminal FALSE:
    "false"
;

terminal FINAL :
    "final"
;

terminal FINALLY :
    "finally"
;

terminal FLOAT :
    "float"
;

terminal FOR :
    "for"
;

terminal GOTO :
    "goto"
;

terminal IF :
    "if"
;

terminal IMPLEMENTS :
    "implements"
;

terminal IMPORT :
    "import"
;

terminal INSTANCEOF :
    "instanceof"
;

terminal INT :
    "int"
;

terminal INTERFACE :
    "interface"
;

terminal LONG :
    "long"
;

terminal NATIVE :
    "native"
;

terminal NEW :
    "new"
;

terminal NULL :
    "null"
;

terminal PACKAGE :
    "package"
;

terminal PRIVATE :
    "private"
;

terminal PROTECTED :
    "protected";

terminal PUBLIC :
    "public"
;

terminal RETURN :
    "return"
;

terminal SHORT :
    "short"
;

terminal STATIC :
    "static"
;

terminal SUPER :
    "super"
;

terminal SWITCH :
    "switch"
;

terminal SYNCHRONIZED :
    "synchronized"
;

terminal THIS :
    "this"
;

terminal THREADSAFE :
    "threadsafe"
;

terminal THROW :
    "throw"
;

terminal THROWS :
    "throws"
;

terminal TRANSIENT :
    "transient"
;

terminal TRY :
    "try"
;

terminal TRUE:
    "true"
;

terminal VOID :
    "void"
;

terminal VOLATILE :
    "volatile"
;

terminal WHILE :
    "while"
;

terminal EXPONENTIAL :
    "e" ( "+" | "-" )?
;

terminal FLOAT_TYPE_SUFFIX :
    "f" | "d"
;

terminal LONG_TYPE_SUFFIX :
    "l"
;

terminal CHARACTER :
    "'" . "'"
;

terminal STRING:
    '"' ( "\\" . | !( "\\" | '"' ) )* '"'
;

terminal ID :
    ( "a".."z" | "A".."Z" |"_" |"$" )
    ( "a".."z" | "A".."Z" |"_" |"$" | "0".."9" )*
;

terminal DECIMAL_DIGITS returns ecore::EInt :
    ( "0".."9" )+
;

terminal HEXA_DIGITS :
    "0x" ( "0".."9" "a".."f" )+
;

terminal DOC_COMMENT :
    "/*" -> "*/"
;

terminal SL_COMMENT :
    "//" !( "\n" | "\r" )* ( "\r"? "\n" )?
;

terminal WS :
    ( " " | "\t" | "\r" | "\n" )+
;

CompilationUnit :
    {CompilationUnit} package=PackageStatement? imports+=ImportStatement* declarations+=TypeDeclaration*
;

PackageStatement :
    PACKAGE name=PackageName ";"
;

ImportStatement :
    IMPORT ( ( package_name=PackageName ".*" ) | class_name=ClassName ) ";"
;

TypeDeclaration :
    comment=DOC_COMMENT? ( name=ClassDeclaration | name=InterfaceDeclaration )
;

ClassDeclaration :
    modifiers+=Modifier* CLASS class_name=ID
    ( EXTENDS extend=ClassName )?
    ( IMPLEMENTS implements+=InterfaceName ( "," implements+=InterfaceName )* )?
    "{" fields+=FieldDeclaration* "}"
;

InterfaceDeclaration :
    modifiers+=Modifier* INTERFACE interface_name=ID
    ( EXTENDS extends+=InterfaceName ( "," extends+=InterfaceName )* )?
    "{" fields+=FieldDeclaration* "}"
;

//===============================================
/* Possible Ambiguity Here */

PackageName :
    ID (=> "." ID )*
;

ClassName :
    PackageName
;

InterfaceName :
    PackageName
;

//===============================================

Modifier :
    PUBLIC
    | PRIVATE
    | PROTECTED
    | STATIC
    | FINAL
    | NATIVE
    | SYNCHRONIZED
    | ABSTRACT
    | THREADSAFE
    | TRANSIENT
;

LiteralSpecifier :
    BOOLEAN
    | BYTE
    | CHAR
    | SHORT
    | INT
    | FLOAT
    | LONG
    | DOUBLE
    | VOID
;

TypeSpecifier :
    LiteralSpecifier
    | ClassName
;

FieldDeclaration returns FieldDeclaration :
    ( comment=DOC_COMMENT?
    ( name=MethodDeclaration | name=ConstructorDeclaration | name=VariableDeclaration ) )
    | name=StaticInitializer
    | ";"
;

MethodDeclaration :
    modifiers+=Modifier* type=Type name=ID
    "(" parameters=ParameterList? ")"
    ( "[]" )* ( statement=StatementBlock | ";" )
;

ConstructorDeclaration :
    modifiers+=Modifier*
    name=ID "(" parameters=ParameterList? ")"
    statement=StatementBlock
;

VariableDeclaration :
    modifiers+=Modifier*
    type=Type variables+=VariableDeclarator ( "," variables+=VariableDeclarator )* ";"
;

StaticInitializer :
    STATIC statement=StatementBlock
;

Type:
    name=TypeSpecifier ( "[]" )*
;

ParameterList :
    parameters+=Parameter ( "," parameters+=Parameter )*
;

Parameter :
    type=Type name=ID ( "[]" )*
;

StatementBlock :
    "{" statements+=Statement* "}"
;

VariableDeclarator :
    name=ID ( "[]" )* ( "=" value=VariableInitializer )?
;

VariableInitializer :
    expression=Expression |
    (=> "{" ( values+=VariableInitializer
    ( "," values+=VariableInitializer )* ( "," )? )? "}" )
;

Statement :
    declaration=VariableDeclaration
    | ( expression=Expression ";" )
    | block_statement=StatementBlock
    | if_statement=IfStatement
    | do_statement=DoStatement
    | while_statement=WhileStatement
    | for_statement=ForStatement
    | try_statement=TryStatement
    | switch_statement=SwitchStatement
    | ( SYNCHRONIZED "(" expression=Expression ")" statement=Statement )
    | ( RETURN expression=Expression? ";" )
    | ( THROW  expression=Expression  ";" )
    | ( name=ID ":" statement=Statement )
    | ( BREAK    name=ID? ";" )
    | ( CONTINUE name=ID? ";" )
    | ";"
;

Expression returns Expression :
    ( numeric_expression=NumericExpression
    | logical_expression=LogicalExpression
    | bit_expression=BitExpression
    | casting_expression=CastingExpression
    | creating_expression=CreatingExpression
    | literal_expression=LiteralExpression
    | NULL
    | SUPER
    | THIS
    | name=ID
    ) expression=ExpressionTerminal
;

ExpressionTerminal returns Expression :
    (=> "(" args=ArgList? ")" ) next_expression=ExpressionTerminal
    |=> ( "[" expression=Expression "]" ) next_expression=ExpressionTerminal
    //TODO(diegoadolfo): fix bug to enable this correct prodution rule
    |=> ( "->" expression=Expression )
    |=> ( "," expression=Expression )
    |=> ( "?" then=Expression ":" else=Expression )
    |=> ( INSTANCEOF class_name=ClassName ) next_expression=ExpressionTerminal
    |=> bit_signal=( ">>="|"<<"|">>"|">>>" ) expression=Expression
    |=> posfix_signal =( "++"|"--" ) expression=Expression
    |=> string_signal =( "+"|"+=" ) expression=Expression
    |=> numeric_signal=( "+"|"+="|"-"|"-="|"*"|"*="|"/"|"/="|"%"|"%=" ) expression=Expression
    |=> testing_signal=( ">"|"<"|">="|"<="|"=="|"!=" ) expression=Expression
    |=> logical_signal=( AmpersandSignal|"|"|"|="|"^"|"^="|"||="|"%"|"%=" ) expression=Expression
    | {ExpressionTerminal}
;

IfStatement :
    IF "(" condition=Expression ")" then=Statement
    (=> ELSE else=Statement )?
;

DoStatement :
    DO statement=Statement
    WHILE "(" condition=Expression ")" ";"
;

WhileStatement :
    WHILE "(" condition=Expression ")" statement=Statement
;

ForStatement :
    FOR "("
    ( variable_declaration=VariableDeclaration | ( expression=Expression ";" ) | ";" )
    ( condition=Expression? ";" )
    ( increment=Expression? ";" ) ")"
    statement=Statement
;

TryStatement :
    TRY try_statement=Statement
    (=> CATCH "(" exception=Parameter ")" catch_statement=Statement )*
    (=> FINALLY finally_statement=Statement )?
;

SwitchStatement :
    SWITCH "(" switch_value=Expression ")" "{"
    ( CASE case_values+=Expression ":" statements+=Statement )*
    ( DEFAULT ":" default_statement=Statement )? "}"
;

NumericExpression:
    prefix_signal=( "-"|"++"|"--" ) expression=Expression
;

LogicalExpression :
    ( "!" expression=Expression ) | TRUE | FALSE
;

BitExpression:
    "~" expression=Expression
;

CastingExpression :
    ( "(" type=Type ")" expression=Expression )
;

CreatingExpression:
    NEW ( ( class_name=ClassName  args=ArgsCreateExpression )
    | ( type=LiteralSpecifier (=> "["  expression=Expression "]" )? ( "[]" )* )
    | (=> "(" expression=Expression ")" ) )
;

ArgsCreateExpression :
    (=> "(" args=ArgList? ")" )
    | (=> "[" expression=Expression "]" )? ( "[]" )*
;

LiteralExpression :
    DECIMAL_DIGITS NumericLiteral
    | FloatTerminal | HEXA_DIGITS LONG_TYPE_SUFFIX? | STRING | CHARACTER
;

ExponentPart :
    EXPONENTIAL DECIMAL_DIGITS
;

NumericLiteral :
    (=> "." DECIMAL_DIGITS? ExponentPart? FLOAT_TYPE_SUFFIX? ) | LONG_TYPE_SUFFIX?
;

FloatTerminal :
    (=> "." DECIMAL_DIGITS ExponentPart? FLOAT_TYPE_SUFFIX? )
;

ArgList :
    expressions+=Expression ( "," expressions+=Expression )*
;

AmpersandSignal:
    AMPERSAND ( AMPERSAND | "=" )?
;
