grammar org.myasm.assembly.compiler.MyAsm hidden(WS, DOC_COMMENT, SL_COMMENT)

generate myAsm "http://www.myasm.org/assembly/compiler/MyAsm"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// ===============================================
// ===              Java Program               ===
// ===============================================

Program:
	program=CompilationUnit
;

CompilationUnit:
    package=PackageDeclaration? imports+=ImportDeclaration* declarations+=TypeDeclaration*
;

// ===============================================
// ===               Declarations              ===
// ===============================================

PackageDeclaration:
    => PACKAGE name=PackageName ";"
;

ImportDeclaration:
    => IMPORT ( package=PackageName ".*" | object=TypeName ) ";"
;

TypeDeclaration:
    type=( ClassDeclaration | InterfaceDeclaration )
;

ClassDeclaration returns Class:
    modifiers+=ClassModifier*
    CLASS name=IDENTIFIER extends=Inheritance? implements=Interfaces? body=ClassBody
;

ClassModifier:
    PUBLIC | ABSTRACT | FINAL
;

Inheritance:
    EXTENDS superClass=ClassType
;

Interfaces:
    IMPLEMENTS interfaces+=InterfaceType (=> "," interfaces+=IntegralType )*
;

ClassBody:
    "{" declarations+=ClassBodyDeclaration* "}"
;

ClassBodyDeclaration:
      classMember=ClassMemberDeclaration
    | staticBlock=StaticInitializer
    | classConstructor=ConstructorDeclaration
;

ClassMemberDeclaration:
    attribute=FieldDeclaration | method=MethodDeclaration
;

StaticInitializer:
    STATIC body=Block
;

ConstructorDeclaration returns Constructor:
    modifiers+=ConstructorModifier*
    header=ConstructorDeclarator throws=Exceptions? body=ConstructorBody
;

ConstructorModifier:
    PUBLIC | PROTECTED | PRIVATE
;

ConstructorDeclarator:
    name=SimpleTypeName
    "(" ( params+=FormalParameter (=> "," params+=FormalParameter )* )? ")"
;

FormalParameter:
    type=Type variable=VariableDeclaratorId
;

Exceptions:
    THROWS exceptions+=ClassType (=> "," exceptions+=ClassType )*
;

ConstructorBody:
    "{" selfInvocation=ExplicitConstructorInvocation? statements+=BlockStatement* "}"
;

ExplicitConstructorInvocation:
    ( THIS "(" args=ArgumentList? ")" ) | ( SUPER "(" args=ArgumentList? ")" )
;

FieldDeclaration returns Variable:
    modifiers+=FieldModifier*
    type=Type variables+=VariableDeclarator (=> "," variables+=VariableDeclarator )* ";"
;

FieldModifier:
    PUBLIC | PROTECTED | PRIVATE | STATIC | FINAL | TRANSIENT | VOLATILE
;

VariableDeclarator:
    name=VariableDeclaratorId
    ( "=" value=VariableInitializer )?
;

VariableDeclaratorId:
    IDENTIFIER ( "[]" )*
;

VariableInitializer:
    expression=Expression | array=ArrayInitializer
;

MethodDeclaration returns Method:
    signature=MethodHeader ( body=Block | ";" )
;

MethodHeader:
    modifiers+=MethodModifier*
    returnType=ResultType header=MethodDeclarator throws=Exceptions?
;

ResultType returns Type:
    Type | VOID
;

MethodModifier:
    PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL | SYNCHRONIZED | NATIVE
;

MethodDeclarator:
    name=IDENTIFIER
    "(" ( params+=FormalParameter (=> "," params+=FormalParameter)* )? ")"
;

InterfaceDeclaration returns Interface:
    modifiers+=InterfaceModifier*
    INTERFACE name=IDENTIFIER extends=ExtendsInterfaces? body=InterfaceBody
;

InterfaceModifier:
    PUBLIC | ABSTRACT
;

ExtendsInterfaces:
    EXTENDS interfaces+=InterfaceType ( "," interfaces+=InterfaceType )*
;

InterfaceBody:
    "{" declarations+=InterfaceMemberDeclaration* "}"
;

InterfaceMemberDeclaration:
    constant=ConstantDeclaration | method=AbstractMethodDeclaration
;

ConstantDeclaration returns Variable:
    modifiers+=ConstantModifiers* type=Type declaration=VariableDeclarator
;

ConstantModifiers:
    PUBLIC | STATIC | FINAL
;

AbstractMethodDeclaration returns Method:
    modifiers+=AbstractMethodModifier*
    returnType=ResultType header=MethodDeclarator throws=Exceptions? ";"
;

AbstractMethodModifier:
    PUBLIC | ABSTRACT
;

ArrayInitializer:
    "{" ( variables+=VariableInitializer (=> "," variables+=VariableInitializer )* )? ","? "}"
;

// ===============================================
// ===                  Types                  ===
// ===============================================

Type returns Type:
    ( PrimitiveType | ReferenceType ) ArrayType*
;

PrimitiveType:
    NumericType | BOOLEAN
;

NumericType:
    IntegralType | FloatingType
;

IntegralType:
    BYTE | SHORT | INT | LONG | CHAR
;

FloatingType:
    FLOAT | DOUBLE
;

ReferenceType:
    TypeName
;

ClassType:
    TypeName
;

InterfaceType:
    TypeName
;

ArrayType:
    "[]"
;

// ===============================================
// ===          Blocks and Commands            ===
// ===============================================

Block:
    "{" statements+=BlockStatement* "}"
;

BlockStatement:
    ( localVariable=LocalVariableDeclaration ";" ) | statement=Statement
;

LocalVariableDeclaration returns Variable:
    type=Type variables+=VariableDeclarator (=> "," variables+=VariableDeclarator )*
;

Statement:
    subStatement=StatementWithoutTrailingSubstatement
    | labelStatement=LabeledStatement
    | ifStatement=IfStatement
    | whileStatement=WhileStatement
    | forStatement=ForStatement
;

StatementWithoutTrailingSubstatement:
    blockStatement=Block
    | emptyStatement=EmptyStatement
    | expressionStatement=ExpressionStatement
    | swtchStatement=SwitchStatement
    | doStatement=DoStatement
    | breakStatemet=BreakStatement
    | continueStatement=ContinueStatement
    | returnStatement=ReturnStatement
    | syscStatement=SynchronizedStatement
    | throwStatement=ThrowsStatement
    | tryStatement=TryStatement
;

EmptyStatement:
    ";"
;

LabeledStatement:
    label=IDENTIFIER ":" statement=Statement
;

ExpressionStatement:
    expression=StatementExpression ";"
;

StatementExpression:
     => assignment=Assignment
    | expression=PreIncrementExpression
    | expression=PreDecrementExpression
    |=> expression=PostfixExpression
    |=> methodCall=MethodInvocation
    |=> classCreate=ClassInstanceCreationExpression
;

IfStatement:
    IF "(" condition?=Expression ")" then=Statement
    (=> ELSE else=Statement )?
;

SwitchStatement:
    SWITCH "(" expression=Expression ")" "{"
    ( ( CASE constantExpr+=ConstantExpression ":" )
    | ( DEFAULT ":" )
    | statements+=BlockStatement )* "}"
;

WhileStatement:
    WHILE "(" condition?=Expression ")" statement=Statement
;

DoStatement:
    DO statement=Statement WHILE "(" condition?=Expression ")" ";"
;

ForStatement:
    FOR "(" declaration=ForInit? ";" condition?=Expression? ";" updateExpr=ForUpdate? ")"
    statement=Statement
;

ForInit:
    ( expressions+=StatementExpression (=> "," expressions+=StatementExpression )* )
    | variable=LocalVariableDeclaration
;

ForUpdate:
    expressions+=StatementExpression
    (=> "," expressions+=StatementExpression )*
;

BreakStatement:
    BREAK reference=IDENTIFIER? ";"
;

ContinueStatement:
    CONTINUE reference=IDENTIFIER? ";"
;

ReturnStatement:
    RETURN expression=Expression? ";"
;

ThrowsStatement:
    THROW  expression=Expression  ";"
;

SynchronizedStatement:
    SYNCHRONIZED "(" expression=Expression ")" synsBlock=Block
;

TryStatement:
    TRY tryBlock=Block
    (=> CATCH "(" params+=FormalParameter ")" catchBlocks+=Block )*
    (=> FINALLY finallyBlock=Block )?
;

// ===============================================
// ===                 Expression              ===
// ===============================================

ConstantExpression:
    constant=Expression
;

Expression:
    expression=AssignmentExpression
;

AssignmentExpression:
    => condition?=ConditionalExpression | assigment=Assignment
;

Assignment returns Assigment:
    object=LeftHandSide operator=AssignmentOperator value=AssignmentExpression
;

LeftHandSide:
      => reference=ExpressionName
    | => fieldAccess=FieldAccess
    | => arrayAccess=ArrayAccess
;

AssignmentOperator:
    "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="
;

ConditionalExpression:
    condition?=ConditionalOrExpression
    (=> "?" then=Expression ":" else=ConditionalExpression )?
;

ConditionalOrExpression:
    expressions+=ConditionalAndExpression
    (=> operators+="||" expressions+=ConditionalAndExpression )*
;

ConditionalAndExpression:
    expressions+=InclusiveOrExpression
    (=> operators+="&&" expressions+=InclusiveOrExpression )*
;

InclusiveOrExpression:
    expressions+=ExclusiveOrExpression
    (=> operators+="|" expressions+=ExclusiveOrExpression )*
;

ExclusiveOrExpression:
    expressions+=AndExpression
    (=> operators+="^" expressions+=AndExpression )*
;

AndExpression:
    expressions+=EqualityExpression
    (=> operators+="&" expressions+=EqualityExpression )*
;

EqualityExpression:
    expressions+=RelationalExpression
    (=> operators+=( "==" | "!=" ) expressions+=RelationalExpression )*
;

RelationalExpression:
    expressions+=ShiftExpression
    ( => ( operators+=( "<" | ">" | "<=" | ">=" ) expressions+=ShiftExpression )
    | => ( operators+=INSTANCEOF classes+=ReferenceType ) )*
;

ShiftExpression:
    expressions+=AdditiveExpression
    (=> operator+=( "<<" | ">>" | ">>>" ) expressions+=AdditiveExpression )*
;

AdditiveExpression:
    expressions+=MultiplicativeExpression
    (=> operators+=( "+" | "-" ) expressions+=MultiplicativeExpression )*
;

MultiplicativeExpression:
    expressions+=NoArrayExpression
    (=> operators+=( "*" | "/" | "%" ) expressions+=NoArrayExpression )*
;

CastExpression:
     => "(" type=PrimitiveType ")" expression=NoArrayExpression
    |=> "(" type=ReferenceType ")" expression=NoArrayExpressionWithoutMinus
;

NoArrayExpression:
      expression=PreIncrementExpression
    | expression=PreDecrementExpression
    | operator="+" expression=NoArrayExpression
    | operator="-" expression=NoArrayExpression
    | expression=NoArrayExpressionWithoutMinus
;

PreDecrementExpression:
    operator="--" expression=NoArrayExpression
;

PreIncrementExpression:
    operator="++" expression=NoArrayExpression
;

NoArrayExpressionWithoutMinus:
    => expression=PostfixExpression
    | operator="~" expression=NoArrayExpression
    | operator="!" expression=NoArrayExpression
    | expression=CastExpression
;

PostfixExpression:
    ( => object=Primary | reference=ExpressionName ) operators+=( "--" | "++" )*
;

MethodInvocation:
      ( method=MethodName "(" args=ArgumentList? ")" )
    | => ( object=Primary "." method=IDENTIFIER "(" args=ArgumentList? ")" )
    | => ( super =SUPER   "." method=IDENTIFIER "(" args=ArgumentList? ")" )
;

FieldAccess:
    ( object=Primary "." field=IDENTIFIER ) | => ( super=SUPER "." field=IDENTIFIER )
;

Primary:
    => reference=( PrimaryNoNewArray | PrimaryNewArray )
;

PrimaryNoNewArray:
    ( literal=Literal
    | this=THIS
    | ( "(" expression=Expression ")" )
    | class=ClassInstanceCreationExpression
    | super=SUPER
    | ( method=MethodName "(" args+=ArgumentList? ")" )
    | ( reference=ExpressionName dimentions+=DimentionsExpression ) )
    => ( ( "." fields+=IDENTIFIER ( "(" args+=ArgumentList? ")" )? )
    | dimentions+=DimentionsExpression )*
;

PrimaryNewArray:
    array=ArrayCreationExpression
    => ( ( "." fields+=IDENTIFIER ( "(" args+=ArgumentList? ")" )? )
    | dimentions+=DimentionsExpression )*
;

ClassInstanceCreationExpression:
    NEW class=ClassType "(" args=ArgumentList? ")"
;

ArgumentList:
    expression+=Expression (=> "," expressions+=Expression )*
;

ArrayCreationExpression:
    NEW ( type=PrimitiveType | type=TypeName )
    => fields+=DimentionsExpression+ dimentions+=ArrayType*
;

DimentionsExpression:
    "[" expression=Expression "]"
;

ArrayAccess:
    ( => reference=ExpressionName | array=PrimaryNoNewArray ) field=DimentionsExpression
;

// ===============================================
// ===                 Tokens                  ===
// ===============================================

PackageName:
    IDENTIFIER
    (=> "." IDENTIFIER )*
;

TypeName:
    IDENTIFIER
    (=> "." IDENTIFIER )*
;

SimpleTypeName:
    IDENTIFIER
;

ExpressionName:
    IDENTIFIER
    (=> "." IDENTIFIER )*
;

MethodName:
    IDENTIFIER
    (=> "." IDENTIFIER )*
;

AmbiguousName:
    IDENTIFIER
    ( => "." IDENTIFIER )*
;

Literal:
    IntegerLiteral | FloatingLiteral | BooleanLiteral | CHARACTER_LITERAL | STRING_LITERAL | NULL
;

IntegerLiteral:
    ( DECIMAL_NUMERAL | HEX_NUMERAL | OCTAL_NUMERAL ) ( "l" | "L" )?
;

FloatingLiteral:
    ( ( DECIMAL_NUMERAL "." DECIMAL_NUMERAL* ) | ( "." DECIMAL_NUMERAL ) | DECIMAL_NUMERAL )
    FLOAT_PART_COMPLEMENT
;

BooleanLiteral:
    TRUE | FALSE
;

// ===============================================
// ===                Terminals                ===
// ===============================================

terminal DOC_COMMENT:
    "/*" -> "*/"
;

terminal SL_COMMENT:
    "//" !( "\n" | "\r" )* ( "\r"? "\n" )?
;

terminal WS:
    ( " " | "\t" | "\r" | "\n" )+
;

terminal ABSTRACT:
    "abstract"
;

terminal AMPERSAND:
    "ampersand"
;

terminal BOOLEAN:
    "boolean"
;

terminal BREAK:
    "break"
;

terminal BYTE:
    "byte"
;

terminal CASE:
    "case"
;

terminal CATCH:
    "catch"
;

terminal CHAR:
    "char"
;

terminal CLASS:
    "class"
;

terminal CONST:
    "const"
;

terminal CONTINUE:
    "continue"
;

terminal DEFAULT:
    "default"
;

terminal DO:
    "do"
;

terminal DOUBLE:
    "double"
;

terminal ELSE:
    "else"
;

terminal EXTENDS:
    "extends"
;

terminal FALSE:
    "false"
;

terminal FINAL:
    "final"
;

terminal FINALLY:
    "finally"
;

terminal FLOAT:
    "float"
;

terminal FOR:
    "for"
;

terminal GOTO:
    "goto"
;

terminal IF:
    "if"
;

terminal IMPLEMENTS:
    "implements"
;

terminal IMPORT:
    "import"
;

terminal INSTANCEOF:
    "instanceof"
;

terminal INT:
    "int"
;

terminal INTERFACE:
    "interface"
;

terminal LONG:
    "long"
;

terminal NATIVE:
    "native"
;

terminal NEW:
    "new"
;

terminal NULL:
    "null"
;

terminal PACKAGE:
    "package"
;

terminal PRIVATE:
    "private"
;

terminal PROTECTED:
    "protected";

terminal PUBLIC:
    "public"
;

terminal RETURN:
    "return"
;

terminal SHORT:
    "short"
;

terminal STATIC:
    "static"
;

terminal SUPER:
    "super"
;

terminal SWITCH:
    "switch"
;

terminal SYNCHRONIZED:
    "synchronized"
;

terminal THIS:
    "this"
;

terminal THREADSAFE:
    "threadsafe"
;

terminal THROW:
    "throw"
;

terminal THROWS:
    "throws"
;

terminal TRANSIENT:
    "transient"
;

terminal TRY:
    "try"
;

terminal TRUE:
    "true"
;

terminal VOID:
    "void"
;

terminal VOLATILE:
    "volatile"
;

terminal WHILE:
    "while"
;

terminal IDENTIFIER:
    ( "a".."z" | "A".."Z" |"_" |"$" )
    ( "a".."z" | "A".."Z" |"_" |"$" | "0".."9" )*
;

terminal DECIMAL_NUMERAL:
    "0" | ( NON_ZERO_DIGIT DIGIT* )
;

terminal fragment DIGIT:
    "0" | NON_ZERO_DIGIT
;

terminal fragment NON_ZERO_DIGIT:
    "1" .. "9"
;

terminal HEX_NUMERAL:
    ( "0x" | "0X" ) HEX_DIGIT+
;

terminal fragment HEX_DIGIT:
    "0" .. "9" | "a" .. "f" | "A" .. "F"
;

terminal OCTAL_NUMERAL:
    "0" OCTAL_DIGIT+
;

terminal fragment OCTAL_DIGIT:
    "0" .. "7"
;

terminal FLOAT_PART_COMPLEMENT:
    EXPONENT_PART? FLOAT_TYPE_SUFFIX?
;

terminal fragment EXPONENT_PART:
    EXPONENT_INDICATOR SIGNED_INTEGER
;

terminal fragment EXPONENT_INDICATOR:
    "e" | "E"
;

terminal fragment SIGNED_INTEGER:
    ( "+" | "-" ) DIGIT+
;

terminal fragment FLOAT_TYPE_SUFFIX:
    "f" | "F" | "d" | "D"
;

terminal CHARACTER_LITERAL:
    "'" . | !( "\\" | "'" ) "'"
;

terminal STRING_LITERAL:
    '"' ( "\\" . | !( "\\" | '"' ) )* '"'
;